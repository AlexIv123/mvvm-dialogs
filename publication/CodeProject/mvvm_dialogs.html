<span id="ArticleContent">

    <ul class="download">
        <li><a href="MVVM_Dialogs/MVVM_Dialogs.zip">Download source - ??? KB</a></li>
    </ul>

    <p><img width="625" height="420" src="MVVM_Dialogs/Application.png" complete="true" /></p>

    <h2>Contents</h2>

    <ul>
        <li><a href="#intro">Introduction</a></li>

        <li><a href="#my_mvvm">My Interpretation of MVVM</a></li>

        <li><a href="#dialog_service">The Dialog Service</a></li>

        <li><a href="#what_now">What Now?</a></li>

        <li><a href="#history">History</a></li>
    </ul>

    <h2><a name="intro">Introduction</a></h2>

    <p>This article will address one of the problems a developer might run into when using the MVVM pattern, namely opening dialogs from 
	view models. Basic knowledge of the pattern is expected. Josh Smith has written a fantastic <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">article</a> in MSDN Magazine which can serve as the starting point for those that are unfamiliar with the pattern.</p>

    <p>There already exist some solutions exploring this area, but none of them seem to be widely accepted among the MVVM community. <a href="http://wpfonyx.codeplex.com/">Onyx</a> on CodePlex is probably the most complete solution. Sacha Barber <a href="http://sachabarber.net/?p=518">announced</a> that he is working on a new MVVM framework, but hasn't set any release date. At the same time, <a href="http://groups.google.com/group/wpf-disciples">WPF Disciples</a> are teaming up to create a <a href="http://www.codeplex.com/mvvmref">MVVM reference</a> application, again with no release date yet.</p>

    <h2><a name="my_mvvm">My Interpretation of MVVM</a></h2>

    <p>I am possibly sticking my neck out here, but I would like to state some of my own interpretations of the MVVM pattern:</p>

    <ul>
        <li>The fundamental core is the separation of UI and logic. view model and 
		view can communicate using bindings, making it possible for the view to be happily unaware of the 
		view model and vice versa. I know some of you might say: <em>&quot;well, actually the 
		view knows about the view model since the view model is stored within the DataContext property, and the 
		view is declaring its bindings to match properties on the view model, surely the 
		view must know the view model?&quot;</em>. I don't think so; we have to analyze what <em>knows</em> actually means. The 
		view model is stored in the <code>DataContext</code> property, that is correct, but <code>DataContext</code> is of type <code lang="Cs">Object</code>. From the 
		view's point, the only thing it knows is whether the property has been set or not, nothing about the actual content. Let's get to the bindings declared in the 
		view; do they say something about the view model? I would have to say no here as well. The 
		view might declare whatever bindings it wishes, but the view model isn't enforced to implement them.</li>

        <li>The view model should serve the view with data, but one might argue where the separation between the 
		view and view model is. If for instance the view model is holding a list of items presented in a <code>ListView</code>, I would argue that sorting, grouping, and filtering could be the responsibility of the 
		view, not the view model. Attached properties can solve this for us, making the 
		view model happily unaware of the item presentation.</li>

        <li>The view model should not contain anything used purely in tests; either a class is testable or it isn't.</li>
    </ul>

    <h2><a name="dialog_service">The Dialog Service</a></h2>

    <p>The concept of letting services handle relations between the view model and 
	view seems to be the most accepted solution. My contribution is <code>IDialogService</code>.</p>

<pre lang="Cs">/// &lt;summary&gt;
/// Interface responsible for abstracting view models from views.
/// &lt;/summary&gt;
public interface IDialogService
{
  /// &lt;summary&gt;
  /// Gets the registered views.
  /// &lt;/summary&gt;
  ReadOnlyCollection&lt;FrameworkElement&gt; Views { get; }
  /// &lt;summary&gt;
  /// Registers a view.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;view&quot;&gt;The registered view.&lt;/param&gt;
  void Register(FrameworkElement view);
  /// &lt;summary&gt;
  /// Unregisters a view.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;view&quot;&gt;The unregistered view.&lt;/param&gt;
  void Unregister(FrameworkElement view);
  /// &lt;summary&gt;
  /// Shows a dialog.
  /// &lt;/summary&gt;
  /// &lt;remarks&gt;
  /// The dialog used to represent the view model is retrieved from the registered mappings.
  /// &lt;/remarks&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;viewModel&quot;&gt;The view model of the new dialog.&lt;/param&gt;
  /// &lt;returns&gt;
  /// A nullable value of type bool that signifies how a window was closed by the user.
  /// &lt;/returns&gt;
  bool? ShowDialog(object ownerViewModel, object viewModel);
  /// &lt;summary&gt;
  /// Shows a dialog.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;viewModel&quot;&gt;The view model of the new dialog.&lt;/param&gt;
  /// &lt;typeparam name=&quot;T&quot;&gt;The type of the dialog to show.&lt;/typeparam&gt;
  /// &lt;returns&gt;
  /// A nullable value of type bool that signifies how a window was closed by the user.
  /// &lt;/returns&gt;
  bool? ShowDialog&lt;T&gt;(object ownerViewModel, object viewModel) where T : Window;
  /// &lt;summary&gt;
  /// Shows a message box.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the message box.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;messageBoxText&quot;&gt;A string that specifies the text to display.&lt;/param&gt;
  /// &lt;param name=&quot;caption&quot;&gt;A string that specifies the title bar caption to display.&lt;/param&gt;
  /// &lt;param name=&quot;button&quot;&gt;
  /// A MessageBoxButton value that specifies which button or buttons to display.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;icon&quot;&gt;A MessageBoxImage value that specifies the icon to display.&lt;/param&gt;
  /// &lt;returns&gt;
  /// A MessageBoxResult value that specifies which message box button is clicked by the user.
  /// &lt;/returns&gt;
  MessageBoxResult ShowMessageBox(
    object ownerViewModel,
    string messageBoxText,
    string caption,
    MessageBoxButton button,
    MessageBoxImage icon);
  /// &lt;summary&gt;
  /// Shows the OpenFileDialog.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;openFileDialog&quot;&gt;The interface of a open file dialog.&lt;/param&gt;
  /// &lt;returns&gt;DialogResult.OK if successful; otherwise DialogResult.Cancel.&lt;/returns&gt;
  DialogResult ShowOpenFileDialog(object ownerViewModel, IOpenFileDialog openFileDialog);
  /// &lt;summary&gt;
  /// Shows the FolderBrowserDialog.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;folderBrowserDialog&quot;&gt;The interface of a folder browser dialog.&lt;/param&gt;
  /// &lt;returns&gt;The DialogResult.OK if successful; otherwise DialogResult.Cancel.&lt;/returns&gt;
  DialogResult ShowFolderBrowserDialog(object ownerViewModel, 
               IFolderBrowserDialog folderBrowserDialog);
}</pre>

    <p>The actual implementation of <code>IDialogServiceis</code> is <code>DialogService</code>.</p>

<pre lang="Cs">/// &lt;summary&gt;
/// Class responsible for abstracting view models from views.
/// &lt;/summary&gt;
class DialogService : IDialogService
{
  private readonly HashSet&lt;FrameworkElement&gt; views;
  private readonly IWindowViewModelMappings windowViewModelMappings;
  /// &lt;summary&gt;
  /// Initializes a new instance of the &lt;see cref=&quot;DialogService&quot;/&gt; class.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;windowViewModelMappings&quot;&gt;
  /// The window view model mappings. Default value is null.
  /// &lt;/param&gt;
  public DialogService(IWindowViewModelMappings windowViewModelMappings = null)
  {
    this.windowViewModelMappings = windowViewModelMappings;
    views = new HashSet&lt;FrameworkElement&gt;();
  }
  #region IDialogService Members
  /// &lt;summary&gt;
  /// Gets the registered views.
  /// &lt;/summary&gt;
  public ReadOnlyCollection&lt;FrameworkElement&gt; Views
  {
    get { return new ReadOnlyCollection&lt;FrameworkElement&gt;(views.ToList()); }
  }
  /// &lt;summary&gt;
  /// Registers a view.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;view&quot;&gt;The registered view.&lt;/param&gt;
  public void Register(FrameworkElement view)
  {
    // Get owner window
    Window owner = GetOwner(view);
    if (owner == null)
    {
      // Perform a late register when the view hasn't been loaded yet.
      // This will happen if e.g. the view is contained in a Frame.
      view.Loaded += LateRegister;
      return;
    }
    // Register for owner window closing, since we then should unregister view reference,
    // preventing memory leaks
    owner.Closed += OwnerClosed;
    views.Add(view);
  }
  /// &lt;summary&gt;
  /// Unregisters a view.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;view&quot;&gt;The unregistered view.&lt;/param&gt;
  public void Unregister(FrameworkElement view)
  {
    views.Remove(view);
  }
  /// &lt;summary&gt;
  /// Shows a dialog.
  /// &lt;/summary&gt;
  /// &lt;remarks&gt;
  /// The dialog used to represent the view model is retrieved from the registered mappings.
  /// &lt;/remarks&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;viewModel&quot;&gt;The view model of the new dialog.&lt;/param&gt;
  /// &lt;returns&gt;
  /// A nullable value of type bool that signifies how a window was closed by the user.
  /// &lt;/returns&gt;
  public bool? ShowDialog(object ownerViewModel, object viewModel)
  {
    Type dialogType = 
      windowViewModelMappings.GetWindowTypeFromViewModelType(viewModel.GetType());
    return ShowDialog(ownerViewModel, viewModel, dialogType);
  }
  /// &lt;summary&gt;
  /// Shows a dialog.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;viewModel&quot;&gt;The view model of the new dialog.&lt;/param&gt;
  /// &lt;typeparam name=&quot;T&quot;&gt;The type of the dialog to show.&lt;/typeparam&gt;
  /// &lt;returns&gt;
  /// A nullable value of type bool that signifies how a window was closed by the user.
  /// &lt;/returns&gt;
  public bool? ShowDialog&lt;T&gt;(object ownerViewModel, object viewModel) where T : Window
  {
    return ShowDialog(ownerViewModel, viewModel, typeof(T));
  }
  /// &lt;summary&gt;
  /// Shows a message box.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the message box.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;messageBoxText&quot;&gt;A string
  /// that specifies the text to display.&lt;/param&gt;
  /// &lt;param name=&quot;caption&quot;&gt;A string that specifies
  /// the title bar caption to display.&lt;/param&gt;
  /// &lt;param name=&quot;button&quot;&gt;
  /// A MessageBoxButton value that specifies which button or buttons to display.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;icon&quot;&gt;A MessageBoxImage value
  /// that specifies the icon to display.&lt;/param&gt;
  /// &lt;returns&gt;
  /// A MessageBoxResult value that specifies which
  /// message box button is clicked by the user.
  /// &lt;/returns&gt;
  public MessageBoxResult ShowMessageBox(
    object ownerViewModel,
    string messageBoxText,
    string caption,
    MessageBoxButton button,
    MessageBoxImage icon)
  {
    return MessageBox.Show(FindOwnerWindow(ownerViewModel), 
                           messageBoxText, caption, button, icon);
  }
  /// &lt;summary&gt;
  /// Shows the OpenFileDialog.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;openFileDialog&quot;&gt;The interface of a open file dialog.&lt;/param&gt;
  /// &lt;returns&gt;DialogResult.OK if successful;
  /// otherwise DialogResult.Cancel.&lt;/returns&gt;
  public DialogResult ShowOpenFileDialog(object ownerViewModel, 
                      IOpenFileDialog openFileDialog)
  {
    // Create OpenFileDialog with specified view model
    OpenFileDialog dialog = new OpenFileDialog(openFileDialog);
    // Show dialog
    return dialog.ShowDialog(new WindowWrapper(FindOwnerWindow(ownerViewModel)));
  }
  /// &lt;summary&gt;
  /// Shows the FolderBrowserDialog.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;folderBrowserDialog&quot;&gt;The interface
  ///           of a folder browser dialog.&lt;/param&gt;
  /// &lt;returns&gt;The DialogResult.OK if successful;
  ///       otherwise DialogResult.Cancel.&lt;/returns&gt;
  public DialogResult ShowFolderBrowserDialog(object ownerViewModel, 
                      IFolderBrowserDialog folderBrowserDialog)
  {
    // Create FolderBrowserDialog with specified view model
    FolderBrowserDialog dialog = new FolderBrowserDialog(folderBrowserDialog);
    // Show dialog
    return dialog.ShowDialog(new WindowWrapper(FindOwnerWindow(ownerViewModel)));
  }
  #endregion
  #region Attached properties
  /// &lt;summary&gt;
  /// Attached property describing whether
  /// a FrameworkElement is acting as a view in MVVM.
  /// &lt;/summary&gt;
  public static readonly DependencyProperty IsRegisteredViewProperty =
    DependencyProperty.RegisterAttached(
    &quot;IsRegisteredView&quot;,
    typeof(bool),
    typeof(DialogService),
    new UIPropertyMetadata(IsRegisteredViewPropertyChanged));
  /// &lt;summary&gt;
  /// Gets value describing whether FrameworkElement is acting as view in MVVM.
  /// &lt;/summary&gt;
  public static bool GetIsRegisteredView(FrameworkElement target)
  {
    return (bool)target.GetValue(IsRegisteredViewProperty);
  }
  /// &lt;summary&gt;
  /// Sets value describing whether FrameworkElement is acting as view in MVVM.
  /// &lt;/summary&gt;
  public static void SetIsRegisteredView(FrameworkElement target, bool value)
  {
    target.SetValue(IsRegisteredViewProperty, value);
  }
  /// &lt;summary&gt;
  /// Is responsible for handling IsRegisteredViewProperty changes, i.e. whether
  /// FrameworkElement is acting as view in MVVM or not.
  /// &lt;/summary&gt;
  private static void IsRegisteredViewPropertyChanged(DependencyObject target,
    DependencyPropertyChangedEventArgs e)
  {
    // The Visual Studio Designer or Blend will run this code when setting the attached
    // property, however at that point there is no IDialogService registered
    // in the ServiceLocator which will cause
    /// the Resolve method to throw a ArgumentException.
    if (DesignerProperties.GetIsInDesignMode(target)) return;
    FrameworkElement view = target as FrameworkElement;
    if (view != null)
    {
      // Cast values
      bool newValue = (bool)e.NewValue;
      bool oldValue = (bool)e.OldValue;
      if (newValue)
      {
        ServiceLocator.Resolve&lt;IDialogService&gt;().Register(view);
      }
      else
      {
        ServiceLocator.Resolve&lt;IDialogService&gt;().Unregister(view);
      }
    }
  }
  #endregion
  /// &lt;summary&gt;
  /// Shows a dialog.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;ownerViewModel&quot;&gt;
  /// A view model that represents the owner window of the dialog.
  /// &lt;/param&gt;
  /// &lt;param name=&quot;viewModel&quot;&gt;The view model of the new dialog.&lt;/param&gt;
  /// &lt;param name=&quot;dialogType&quot;&gt;The type of the dialog.&lt;/param&gt;
  /// &lt;returns&gt;
  /// A nullable value of type bool that signifies how a window was closed by the user.
  /// &lt;/returns&gt;
  private bool? ShowDialog(object ownerViewModel, object viewModel, Type dialogType)
  {
    // Create dialog and set properties
    Window dialog = (Window)Activator.CreateInstance(dialogType);
    dialog.Owner = FindOwnerWindow(ownerViewModel);
    dialog.DataContext = viewModel;
    // Show dialog
    return dialog.ShowDialog();
  }
  /// &lt;summary&gt;
  /// Finds window corresponding to specified view model.
  /// &lt;/summary&gt;
  private Window FindOwnerWindow(object viewModel)
  {
    FrameworkElement view = 
      views.SingleOrDefault(v =&gt; ReferenceEquals(v.DataContext, viewModel));
    if (view == null)
    {
      throw new ArgumentException(&quot;View<span lang="en-us"> </span>model is not referenced by any registered view.&quot;);
    }
    // Get owner window
    Window owner = view as Window;
    if (owner == null)
    {
      owner = Window.GetWindow(view);
    }
    // Make sure owner window was found
    if (owner == null)
    {
      throw new InvalidOperationException(&quot;View is not contained within a Window.&quot;);
    }
    return owner;
  }
  /// &lt;summary&gt;
  /// Callback for late view register.
  /// It wasn't possible to do a instant register since the
  /// view wasn't at that point part of the logical nor visual tree.
  /// &lt;/summary&gt;
  private void LateRegister(object sender, RoutedEventArgs e)
  {
    FrameworkElement view = sender as FrameworkElement;
    if (view != null)
    {
      // Unregister loaded event
      view.Loaded -= LateRegister;
      // Register the view
      Register(view);
    }
  }
  /// &lt;summary&gt;
  /// Handles owner window closed, view service should then unregister all views acting
  /// within the closed window.
  /// &lt;/summary&gt;
  private void OwnerClosed(object sender, EventArgs e)
  {
    Window owner = sender as Window;
    if (owner != null)
    {
      // Find views acting within closed window
      IEnumerable&lt;FrameworkElement&gt; windowViews =
        from view in views
        where Window.GetWindow(view) == owner
        select view;
      // Unregister views in window
      foreach (FrameworkElement view in windowViews.ToArray())
      {
        Unregister(view);
      }
    }
  }
  /// &lt;summary&gt;
  /// Gets the owning Window of a view.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;view&quot;&gt;The view.&lt;/param&gt;
  /// &lt;returns&gt;The owning Window if found; otherwise null.&lt;/returns&gt;
  private Window GetOwner(FrameworkElement view)
  {
    return view as Window ?? Window.GetWindow(view);
  }
}</pre>

    <p>The design is pretty straightforward. A view is registering itself as part of the MVVM pattern by setting the attached property <code>IsRegisteredView</code> on any element in the logical tree.</p>

<pre lang="Xml">&lt;Window
  x:Class=&quot;MVVM_Dialogs.View.MainWindow&quot;
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  xmlns:service=&quot;clr-namespace:MVVM_Dialogs.Service&quot;
  service:DialogService.IsRegisteredView=&quot;True&quot;&gt;</pre>

    <p>The view is now remembered by the dialog service. When a view model is in need to show some kind of dialog, the correct 
	view is found by the service, and its owning Window is used as the owner.</p>

    <h3><a name="dialog_service_showing_dialog">Showing a Dialog from a view 
	model</a></h3>

    <p>There exist two overloads for using the <code>ShowDialog</code> method. The first one lets the developer specify the dialog type. </p>

<pre lang="Cs">public class MainWindowViewModel : ViewModelBase
{
  ...
  private void ShowInformation(object o)
  {
    // Get the selected person view model
    PersonViewModel selectedPerson = persons.Single(p =&gt; p.IsSelected);
    // Create the PersonDialog view model
    PersonDialogViewModel personDialogViewModel = 
              new PersonDialogViewModel(selectedPerson.Person);
    // Showing the dialog, alternative 1.
    // Showing a specified dialog. This doesn't require any form of mapping using 
    // IWindowViewModelMappings.
    dialogService.ShowDialog&lt;PersonDialog&gt;(this, personDialogViewModel);
  }
}</pre>

    <p>This overload specifies that a <code>PersonDialog</code> should be displayed with <code lang="Cs">this</code> as the owner and <code>personDialogViewModel</code> as <code>DataContext</code>. However, some of you might find it unsuitable that a 
	view is specified in a view model. For you, there is a second overload.</p>

<pre lang="Cs">public class MainWindowViewModel : ViewModelBase
{
  ...
  private void ShowInformation(object o)
  {
    // Get the selected person view model
    PersonViewModel selectedPerson = persons.Single(p =&gt; p.IsSelected);
    // Create the PersonDialog view model
    PersonDialogViewModel personDialogViewModel = 
                new PersonDialogViewModel(selectedPerson.Person);
    // Showing the dialog, alternative 2.
    // Showing a dialog without specifying the type.
    // This require some form of mapping using 
    // IWindowViewModelMappings.
    dialogService.ShowDialog(this, personDialogViewModel);
  }
}
/// &lt;summary&gt;
/// Class describing the Window-view model mappings used by the dialog service.
/// &lt;/summary&gt;
public class WindowViewModelMappings : IWindowViewModelMappings
{
  private IDictionary&lt;Type, Type&gt; mappings;
  /// &lt;summary&gt;
  /// Initializes a new instance of the &lt;see cref=&quot;WindowViewModelMappings&quot;/&gt; class.
  /// &lt;/summary&gt;
  public WindowViewModelMappings()
  {
    mappings = new Dictionary&lt;Type, Type&gt;
    {
      { typeof(PersonDialogViewModel), typeof(PersonDialog) }
    };
  }
  /// &lt;summary&gt;
  /// Gets the window type based on registered view model type.
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;viewModelType&quot;&gt;The type of the view model.&lt;/param&gt;
  /// &lt;returns&gt;The window type based on registered view model type.&lt;/returns&gt;
  public Type GetWindowTypeFromViewModelType(Type viewModelType)
  {
    return mappings[viewModelType];
  }
}</pre>

    <p>This overload doesn't specify the dialog type; however, you are forced to register the Window-view 
	model mappings in a class implementing <code>IWindowViewModelMappings</code>.</p>

    <h2><a name="what_now">What Now?</a></h2>

    <p>I would like to hear your thoughts about the idea. Perhaps you have a better solution? Don't be afraid, leave a comment...</p>

    <h2><a name="history">History</a></h2>

    <ul>
        <li>5 October 2010: Code update.</li>

        <ul>
            <li>Updated source according to <a href="MVVM_Dialogs.aspx?msg=3603145#xx3603145xx">comments</a> by d302241.</li>
        </ul>

        <li>4 April 2010: Code update.</li>

        <ul>
            <li>Updated source according to <a href="MVVM_Dialogs.aspx?msg=3422401#xx3422401xx">comments</a> by Michael Sync.</li>

            <li>Converted to .NET 4.</li>
        </ul>

        <li>18 June 2009: Code update.</li>

        <ul>
            <li>Code no longer throws exception in Designer mode.</li>

            <li>Fixed wrong interface summary.</li>
        </ul>

        <li>2 June 2009: Code update.</li>

        <ul>
            <li>Added the <code>ShowOpenFileDialog</code> method to <code>IDialogService</code>.</li>

            <li>Implemented a service locator instead of keeping <code>DialogService</code> as a Singleton.</li>
        </ul>

        <li>27 May 2009: Article update.</li>

        <ul>
            <li>Updated introduction after comments from William E. Kempf.</li>
        </ul>

        <li>25 May 2009: Initial version.</li>
    </ul>

</span>